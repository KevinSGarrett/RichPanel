name: PR Bugbot Required

on:
  pull_request_target:
    types: [opened, reopened, synchronize]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  bugbot-check:
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Bugbot review
        id: trigger
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed("No pull_request payload found.");
              return;
            }
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = pr.number;
            const marker = `<!-- bugbot:trigger sha:${pr.head.sha} -->`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100,
            });
            const existing = comments.find((c) => String(c.body || "").includes(marker));
            if (existing) {
              core.info("Trigger already exists for this head SHA.");
              core.setOutput("trigger_created_at", existing.created_at);
              core.setOutput("trigger_marker", marker);
              return;
            }

            const created = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: `${marker}\n@cursor review`,
            });
            core.info("Posted @cursor review trigger comment.");
            core.setOutput("trigger_created_at", created.data.created_at);
            core.setOutput("trigger_marker", marker);

      - name: Wait for Bugbot evidence
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed("No pull_request payload found.");
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = pr.number;
            const triggerCreatedAt = `${{ steps.trigger.outputs.trigger_created_at }}`;

            const minRuntimeMs = 5 * 60 * 1000;   // enforce non-trivial runtime
            const maxRuntimeMs = 20 * 60 * 1000;  // fail if no evidence arrives
            const pollMs = 15 * 1000;

            const startMs = Date.now();
            const triggerMs = Date.parse(triggerCreatedAt || new Date().toISOString());

            function isRecent(ts) {
              if (!ts || !triggerCreatedAt) return true;
              return String(ts) >= triggerCreatedAt;
            }

            function hasBugbotSignal(body) {
              const b = String(body || "");
              return (
                b.includes("BUGBOT_BUG_ID") ||
                b.includes("Fix in Cursor") ||
                b.includes("cursor.com/open?data=") ||
                b.includes("High Severity") ||
                b.includes("Medium Severity")
              );
            }

            while (Date.now() - startMs < maxRuntimeMs) {
              const reviewComments = await github.paginate(
                github.rest.pulls.listReviewComments,
                { owner, repo, pull_number, per_page: 100 }
              );
              const reviewHit = reviewComments.find(
                (c) =>
                  String(c.user?.login || "") === "cursor[bot]" &&
                  isRecent(c.updated_at || c.created_at) &&
                  hasBugbotSignal(c.body)
              );

              const issueComments = await github.paginate(
                github.rest.issues.listComments,
                { owner, repo, issue_number: pull_number, per_page: 100 }
              );
              const issueHit = issueComments.find(
                (c) =>
                  String(c.user?.login || "") === "cursor[bot]" &&
                  isRecent(c.updated_at || c.created_at) &&
                  hasBugbotSignal(c.body)
              );

              if (reviewHit || issueHit) {
                const elapsed = Date.now() - triggerMs;
                if (elapsed < minRuntimeMs) {
                  const remaining = Math.ceil((minRuntimeMs - elapsed) / 1000);
                  core.info(
                    `Bugbot evidence found; waiting ${remaining}s to satisfy minimum runtime.`
                  );
                  await new Promise((r) => setTimeout(r, pollMs));
                  continue;
                }
                core.info("Bugbot review evidence detected from cursor[bot].");
                return;
              }

              core.info("No Bugbot evidence yet; waiting 15s...");
              await new Promise((r) => setTimeout(r, pollMs));
            }

            core.setFailed(
              "Timed out waiting for cursor[bot] Bugbot review evidence after @cursor review trigger."
            );

