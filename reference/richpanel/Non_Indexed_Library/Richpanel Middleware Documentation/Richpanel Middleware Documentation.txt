Richpanel Middleware Documentation Gaps & Expansion Suggestions
Integration Triggers & Automation Rules

Alternate Event Triggers – The current docs focus almost entirely on triggering middleware on new incoming customer messages, but they don’t mention other events that can trigger webhooks. In Richpanel’s automation rules, you can also trigger HTTP Targets on events like conversation status changes or agent replies. For example, a rule could fire when a ticket is resolved/closed or when an agent sends a reply, not just on customer messages. The documentation should note these possibilities and how to configure them. This would broaden the integration use-cases beyond the “new message” scenario (which is currently emphasized). Of course, if using agent replies or status-change triggers, you must add conditions to avoid loops (e.g. ensure “author is Customer” for new-message triggers as already suggested, or only trigger on status change events that aren’t caused by the middleware itself). Including these alternate triggers in the docs, with examples (like “on ticket resolved, call an external survey API”), would fill a missing topic area.

Multiple Webhooks & Rule Interactions – It’s not explicitly covered how Richpanel handles multiple automation rules that call webhooks. The documentation should clarify that if more than one rule’s conditions are met (e.g. two different HTTP Targets set to trigger on a new ticket), Richpanel will call each webhook. There isn’t a guaranteed execution order for multiple rules on the same event, so integrators should design middleware to handle near-simultaneous calls gracefully (or use rule conditions to prevent conflicts). For instance, one rule could add a tag when it runs so that a second rule does not run on the same ticket if that tag is present. Currently, the docs warn about duplicate loops and retriggers, but an explicit note on multiple distinct webhooks firing on one event would be helpful. We suggest adding guidance like: “If you have multiple HTTP Targets for similar events, consider combining them or using conditions to ensure they don’t step on each other. Richpanel does not guarantee a specific order of execution for automation rules triggered by the same event.” This would extend the Automation Rules section to cover complex setups.

Crafting Webhook Payload & Event Data

Available Placeholder Fields – The documentation explains that you can insert placeholders like {{ticket.id}} or customer info in the webhook JSON payload, but it doesn’t provide a full reference of all available placeholders/fields. It would be beneficial to expand this section with a table or list of common fields that can be used in automation webhooks (e.g., ticket properties like {{ticket.createdAt}}, {{ticket.status}}, {{ticket.url}}, customer properties like {{ticket.customer.email}}, {{ticket.customer.name}}, last message text, last order details, etc.). Currently, only a few examples are given. If Richpanel’s official docs list these fields somewhere, referencing that or including a partial list in this guide would add clarity. This ensures developers don’t miss critical data they might need in the webhook (for example, including a unique ticket identifier, as the docs rightly suggest for idempotency). Detailing placeholders is a minor expansion that would make the webhook payload section more self-sufficient.

Payload Size and Format Clarification – It’s briefly mentioned that Richpanel doesn’t specify a max payload size or exact timeout. The documentation could be expanded to clarify practical limits: for instance, advising to keep payloads small (only necessary fields) to ensure fast delivery. If there’s an unofficial size threshold (e.g. “requests over ~1MB may be problematic”), that could be noted. Additionally, while the docs describe using JSON, they might clarify that Richpanel will send whatever format you configure (JSON, form-encoded, etc.) and that the placeholders must result in valid JSON. This is somewhat implied but explicitly stating “Make sure your payload template produces valid JSON (e.g., wrap text in quotes)” could help prevent user errors. Essentially, no major topics are missing here, but a few clarifications would improve this section’s completeness.

Avoiding Automation Loops

(This category appears to be well covered in the existing documentation.) The instructions about preventing recursive triggers and using tags or conditions to stop loops are thorough. No significant missing topics were found here – the guidance on one-way triggers, tag flags, and not retriggering on API actions is comprehensive. The only minor suggestion is to ensure that this section stays linked with the Triggers section (since avoiding loops is a direct consequence of how one sets up triggers and API calls). For example, when adding content about alternate triggers, remind readers to apply the same loop-avoidance principles in those scenarios. Overall, the loop prevention coverage is solid.

Receiving the Webhook in Your Middleware

Response Expectations & Timeouts – The documentation advises acknowledging webhooks quickly, which is great. One thing to consider adding is what Richpanel does if your middleware doesn’t respond quickly. While it’s noted that Richpanel’s timeout isn’t officially documented, they speculate it’s a few seconds. It might help to explicitly state: “Richpanel will wait only a short time (likely ~5-10 seconds) for your webhook to respond. If it doesn’t get a 200 OK, the call may be considered failed (and Richpanel will not automatically retry).” This sets expectations for developers. Additionally, clarify that Richpanel ignores the response body from your service – only the HTTP status matters. This is usually the case with webhooks, but stating it removes any doubt (so developers know there’s no point in sending a detailed response; all relevant action should be in the Richpanel UI via API calls).

Security Verification – The current docs do mention adding a secret token to verify the source. This could be expanded with an example (e.g., “append ?token=YOUR_SECRET to the webhook URL and check it in your code”) just to reinforce the practice. Also, if Richpanel’s IP addresses are known or fixed, the docs could say whether IP whitelisting is feasible. (They do mention IP whitelisting in general terms, but likely Richpanel’s IPs aren’t officially provided, hence the token method is the way to go). No major gaps here – just ensure the guidance is explicit with examples, which helps implementers.

(Overall, the “Receiving webhook” section is quite comprehensive on using HTTPS, verifying source, idempotency, etc. Aside from the small additions above, it’s well-covered.)

Richpanel API – Performing Actions (Updating Tickets)

Creating New Conversations (Tickets) – As a missing topic, the docs do not currently explain how to create a brand new conversation via API. This is an available feature (the API has a Create Conversation endpoint
developer.richpanel.com
), and documenting it would be useful for certain integration scenarios (like proactively creating tickets from an external trigger). We recommend adding a section on “Creating Conversations via API”. It should describe use cases (e.g. an IoT alert creating a support ticket), and show how to format the API request. For instance, note that you need to provide a customer identifier (email/phone or an existing customer ID) and an initial message or comment so the conversation has content. This addition will fill the gap for those who need to open tickets from their middleware, which currently isn’t covered at all.

Posting Internal Notes – The documentation covers posting public replies (as an agent) via the API, but it’s a bit unclear about internal notes. In fact, from the docs it appears there isn’t a separate API flag for an “internal note” (the summary even states there’s no distinct internal note support via API). To avoid confusion, it’s worth explicitly clarifying this in the API section. For example: “Richpanel’s API does not have a special ‘internal note’ designation for comments – any comment posted via the API with sender_type: "operator" will appear as an agent reply visible to the customer. As a workaround, if you want to add information for internal eyes only, you might prefix the comment with “[Internal]” or use tags, since a true private note cannot be added via the API.” This kind of note would set proper expectations for integrators (so they don’t spend time looking for a feature that isn’t there). It’s more of a clarification than a new topic, but it’s important for middleware that might want to add internal remarks.

File Attachments via API – The ability to attach files (images, PDFs, etc.) in tickets is not addressed in the current documentation. However, Richpanel’s API includes an Upload File endpoint
developer.richpanel.com
. A new subsection should explain how to use this. For example: first call the Upload File API to get a file ID or URL
developer.richpanel.com
, then use the Update Conversation call to attach that file to a reply or note. This is a missing piece for any integration that needs to include screenshots or documents. As part of this addition, mention any constraints (file size limits, allowed file types) – currently only a passing reference exists about file size in “Other Limits”. Including a short example JSON for adding an attachment to a message would greatly help. This topic is currently not covered at all (the user’s compiled API reference for file upload was blank), so adding it is highly recommended.

Clarify Agent/Team ID Retrieval for Assignments – The docs describe how to assign tickets to agents or teams via API (likely by ID), but don’t explain how to get those IDs in the first place. A suggestion is to expand the Assignment section with a note like: “To find the agent or team ID to use for assignment, you can call the List Users API or List Teams API
developer.richpanel.com
, or retrieve a specific user by email
developer.richpanel.com
. Richpanel’s API provides these endpoints so you can map human names to IDs in your middleware.” Including this tip would close a knowledge gap for implementers who might not realize how to obtain the correct IDs. It’s a small clarification that can save developers time when building assignment features.

(Other than these points, the API coverage for things like status updates, tagging, and replying is quite good. The above additions would ensure the API section covers all key actions one might do in a custom integration.)

Data Synchronization (Customers & Orders)

Customer Profile Sync Example – The documentation mentions syncing customer data via the API, but it’s high-level. We suggest adding a concrete example under a “Customer Data via API” section. For instance, show a sample payload for the Create/Update Customer call
developer.richpanel.com
, including fields like email, name, phone, and any external customer ID. This fills a documentation gap by teaching through example. It should also clarify what field is used as the unique key (Richpanel uses email/phone to identify customers
developer.richpanel.com
). An explanation of update behavior is needed – e.g., if you call the API with an email that already exists, Richpanel will update that customer rather than create a duplicate. Detailing required or important fields (at least an email or phone) and how the middleware should handle cases like missing info or errors will make this section more robust. Essentially, it’s expanding the Customer Sync topic from a mention into a guided example with best practices.

Order Data Sync & appClientId – There is a significant opportunity to expand the Orders Sync documentation. The user’s docs do note the existence of an order sync API, but without an example. We recommend adding a “Order Sync via API” section with a JSON example of an order being sent to Richpanel. This example should illustrate key fields: order ID, status, amount, line items, etc., as well as how to reference the customer. Critically, clarify how the order links to a customer – e.g., by including the customer’s email/ID in the payload (userProperties as shown in Richpanel’s event structure
developer.richpanel.com
). Also, the docs should explain the role of appClientId in the orders API. Currently, it’s mentioned that different integrations have different appClientIds and that for custom integrations it might be the API key or a store ID, but this is a bit uncertain. The expansion should provide guidance on finding or setting the appClientId when making the order API call (perhaps instruct the user to check their Richpanel admin or use a provided default). Additionally, instruct that after creating/updating an order via API, you can use the Attach Order call to link it to a conversation so agents see the order in the ticket sidebar. The compiled docs do cover the attach mechanism and how it surfaces the order info in the UI, but integrating that explanation with the order sync process would give a full picture of “send order data and tie it to the ticket.” Including these details and examples will cover the currently missing “how exactly to push order info” topic.

(By adding detailed examples for both customers and orders, the middleware guide will better equip developers to keep Richpanel in sync with their e-commerce data. This was a noticeable gap – especially the lack of a payload example – in the provided docs.)

Reliability & Error Handling

Retry Strategy for Failures – The documentation rightly notes that Richpanel does not automatically retry failed webhook calls and advises making the middleware idempotent and robust. One thing to expand on is what the middleware should do when it encounters an error. The docs suggest catching exceptions so your service doesn’t crash and perhaps logging/alerting on failures, but they could go further. We suggest adding a recommendation for an internal retry queue. For example, if your middleware fails to update Richpanel (perhaps the Richpanel API temporarily returns 500 or your database is down), you should enqueue that event for retry rather than drop it. Currently, “Plan for failures” in the docs mentions monitoring but not explicitly queuing. A new snippet could be: “Implement a retry mechanism: e.g., store failed actions in a queue or database with an exponential backoff for reattempt. Since Richpanel won’t resend the webhook, it’s on you to complete the action later.” This would clarify how to handle guarantees. Also, mentioning a “dead-letter” concept (if something fails repeatedly, alert a human) could be useful. In summary, expand the reliability section with advice on persisting webhook events or results until success, which is an implied best practice not currently spelled out.

Graceful Degradation & Timeouts – Another small expansion: advise developers to timeout their calls to external systems within the middleware. The docs do cover that the webhook itself should be quick, but if the middleware calls third-party APIs, ensure those have reasonable timeouts and error handling. Essentially, “fail fast” and respond 200 to Richpanel even if downstream systems lag. This concept is partly in “acknowledge quickly,” but highlighting it under reliability (with an example of using asynchronous processing or background jobs) reinforces the idea. It ties into not blocking the Richpanel webhook and also not losing track of the task. Including a short scenario (like “if an external API is down, log the event and possibly notify an agent in Richpanel via an internal note that the action will be delayed”) would give more concrete guidance. This isn’t a new topic but an elaboration that strengthens the existing guidance on error handling.

(Overall, the reliability section is good, covering no retries, horizontal scaling, rate limits, etc. These suggestions above ensure developers have a clear game plan for when things go wrong, which the current docs allude to but don’t fully flesh out.)

Scalability & Performance

(The current documentation on scalability is quite thorough – it addresses rate limits, throughput, and even testing at scale. No major missing topics were found in this area.) The guide already discusses horizontal scaling of the middleware (running multiple instances behind a load balancer) and cautions about in-memory state. It also covers Richpanel’s rate limits (50 requests per 30 seconds) and suggests queueing bursts. One possible tiny addition: if Richpanel has any other limits (like a cap on the number of automation rules or HTTP targets), those could be mentioned just for completeness (the docs hint at rule limits on lower plans). But this is not critical. In summary, Scalability is well covered; just ensure the advice remains up-to-date with Richpanel’s latest limits and that developers know to design for spikes (which the docs do mention).

Security & Compliance

(The Security section appears comprehensive, covering API key handling, least privilege, IP whitelisting, GDPR, etc.) There aren’t obvious missing topics in the provided materials. The guide wisely advises using separate API keys with appropriate access and storing them securely, and it talks about GDPR compliance and data handling policies. One minor clarification that could be added: if there are any built-in Richpanel audit logs or security features relevant to integrations (for example, “Richpanel logs all API calls made with your key in an audit log”), that could be mentioned if available. Also, since the docs mention long-term maintenance, it might be good to suggest reviewing Richpanel’s update notes periodically (in case new API versions or deprecations are announced) – basically encouraging an ongoing compliance check so the integration stays secure and functional over time. Again, these are small points; the key security considerations are already in place.

Testing & Deployment

(The documentation covers testing and rollout strategies well – including using a sandbox or staging environment, doing dry-runs, and gradually rolling out the middleware in shadow mode.) There aren’t major omissions here. Perhaps one suggested addition is to encourage using tools like request bin or Postman during development: for example, developers can point the Richpanel HTTP Target to a temporary endpoint (like a request inspector) to capture and examine sample webhook payloads before writing code. This can be implied, but stating it might help those less familiar with webhook debugging. The docs already talk about using a test ticket/customer and not affecting real users initially. Also, they mention training agents about the new integration. All of that is great. So aside from maybe adding a note about dummy endpoints for testing payloads, this section is well-covered. No significant new topics need to be added in Testing & Deployment.

Example Walkthrough (Tutorial)

End-to-End Integration Example – One thing notably missing is a practical example that ties all the pieces together. The documentation is detailed but abstract; providing a concrete walkthrough would greatly enhance it. We suggest adding a tutorial-like section, for instance: “Building a Refund Automation Middleware: A Step-by-Step Example.” This would illustrate how a developer can combine triggers, webhooks, and API calls into a working solution. The example could cover: setting up the Richpanel automation rule (trigger on a certain keyword or event), showing a snippet of the middleware code handling the incoming webhook (with quick 200 OK response and a background task), making an external API call (simulated) to process something, then using the Richpanel API to post an update (e.g. an internal note or a public reply) and perhaps attach an order. By walking through a realistic scenario step-by-step, users can see how all the concepts in the guide come together in context. Currently, the docs give all the building blocks but not the final assembled picture. This addition would not only fill that gap but also serve as a template that developers can mimic for their own needs. It’s essentially an expansion in the form of a worked example or case study, which is often the most valuable part of technical documentation. (For reference, we have prepared an example in the attached materials that demonstrates such a flow in pseudo-code for clarity.)